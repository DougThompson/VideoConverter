#!/usr/bin/env python
'''Subclass of MainFrameBase, which is generated by wxFormBuilder.'''

'''
Copyright (c) 2011-2012 Doug Thompson

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
'''

import os
import wx
import gui
import time
import threading
import subprocess
import PreferenceDialog
from configobj import ConfigObj

class MainFrame( gui.MainFrameBase ):
	
	def __init__( self, parent ):
		gui.MainFrameBase.__init__( self, parent )
		
		# Load the Config instance and populate the form
		config = ConfigObj('config.ini')['Values']
		self.m_tbxDestFolder.Value = config['defaultOutputFolder']
		self.m_tbxInputFolder.Value = config['defaultInputFolder']
		
		if len(self.m_tbxInputFolder.Value) > 0:
			self.addVideoFiles(self.m_tbxInputFolder.Value)
		
	def m_mniOpenInputFolderClick( self, event ):
		self.browseInputFolder()
	
	def m_mniOpenDestinationFolderClick( self, event ):
		self.browseOutputFolder()
	
	def m_btnBrowseInputClick(self, event):
		self.browseInputFolder()
		
	def m_btnBrowseDestClick(self, event):
		self.browseOutputFolder()
		
	def m_btnProcessClick( self, event ):
		# First, make sure at least one video is selected, if not alert the user
		if len(self.m_lstVideos.GetSelections()) > 0:
			# Start a new thread to convert the video via Handbrake
			thread = threading.Thread(target=self.run)
			thread.setDaemon(True)
			thread.start()
		else:
			wx.MessageBox('Please select at least one video to process.', 'No Videos Selected!', wx.OK | wx.ICON_INFORMATION)
					
	def m_mniExitClick(self, event):
		'''Exit the application'''
		self.Close()
	
	def m_mniAboutClick(self, event):
		'''Simple About message box'''
		wx.MessageBox("Video Converter by Doug Thompson.","Video Converter")
	
	def m_mniPreferencesClick(self, event):
		'''Open the Preferences Dialog box'''
		dlg = PreferenceDialog.PreferencesDialog(self)
		dlg.ShowModal()
		dlg.Destroy()
	
	def m_txtInputFolderBlur( self, event ):
		'''Update the video files after user leaves Input Textbox'''
		if len(self.m_tbxInputFolder.Value) > 0:
			self.addVideoFiles(self.m_tbxInputFolder.Value)
	
	def browseInputFolder(self):
		'''Browse for the input folder of movies to convert'''
		dialog = wx.DirDialog(self, "Choose a Input directory:", style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON)
		
		# Set default directory to the value in the Textbox, if it exists
		if os.path.exists(self.m_tbxInputFolder.Value):
			dialog.SetPath(self.m_tbxInputFolder.Value)
		
		# Show the dialog and update the path if OK is clicked
		if dialog.ShowModal() == wx.ID_OK:
			path = dialog.GetPath()
			self.m_tbxInputFolder.Value = path
			self.addVideoFiles(path)

		dialog.Destroy()
	
	def browseOutputFolder(self):
		'''Browse for the output folder of movies to convert'''
		dialog = wx.DirDialog(self, "Choose a root Output directory:", style=wx.DD_DEFAULT_STYLE | wx.DD_NEW_DIR_BUTTON)
		
		# Set default directory to the value in the Textbox, if it exists
		if os.path.exists(self.m_tbxDestFolder.Value):
			dialog.SetPath(self.m_tbxDestFolder.Value)
			
		# Show the dialog and update the path if OK is clicked
		if dialog.ShowModal() == wx.ID_OK:
			self.m_tbxDestFolder.Value = dialog.GetPath()

		dialog.Destroy()
	
	def dirEntries(self, dir_name, subdir, *args):
		'''
			Return a list of file names found in directory 'dir_name'
			
	    	If 'subdir' is True, recursively access subdirectories under 'dir_name'.
	    	Additional arguments, if any, are file extensions to match filenames. Matched
	        	file names are added to the list.
	    	If there are no additional arguments, all files found in the directory are
	        	added to the list.
	    	Example usage: fileList = dirEntries(r'H:\TEMP', False, 'txt', 'py')
	        	Only files with 'txt' and 'py' extensions will be added to the list.
	    	Example usage: fileList = dirEntries(r'H:\TEMP', True)
	        	All files and all the files in subdirectories under H:\TEMP will be added
	        	to the list.
	    '''
		
		fileList = []
		for fname in os.listdir(dir_name):
			dirfile = os.path.join(dir_name, fname)
			if os.path.isfile(dirfile):
				# The item is a file, so check to see if it is to be filtered
				if not args:
					# No filters have been passed, so add the file to the list
					fileList.append(dirfile)
				else:
					# One or more filters have been passed, so check the extensions 
					if os.path.splitext(dirfile)[1][1:].lower() in args:
						fileList.append(dirfile)
						
			# recursively access file names in sub-directories
			elif os.path.isdir(dirfile) and subdir:
				fileList.extend(self.dirEntries(dirfile, subdir, *args))
				
		return fileList

	def addVideoFiles(self, path):
		'''Get the video files in a path, including the sub-directories'''
		
		# Grab all videos in the directory and its subs.  This makes it easy to 
		# pass just the AVCHD folder rather than drilling down.
		fileList = self.dirEntries(path, True, 'mts', 'avi', 'mt2s', 'mpg', 'mpeg')
		self.m_lstVideos.Clear()
		for fname in fileList:
			self.m_lstVideos.Append(fname)

	def appendText(self, text):
		'''Update the Output Textbox with the process message'''
		self.m_tbxOutput.AppendText(text)
		
	def clearText(self, text):
		'''Clear the Output Textbox'''
		self.m_tbxOutput.Clear()
		
	def setStatus(self, text):
		'''Set the Status Bar text'''
		self.m_statusBar.SetStatusText(text)
		
	def run(self):
		'''Thread for executing the long running Handbrake conversion'''
		
		for fname in [self.m_lstVideos.GetString(idx) for idx in self.m_lstVideos.GetSelections()]:
			# First, clear the Output Textbox -- This will (hopefull) keep it from overflowing
			# on multiple file conversions
			wx.CallAfter(self.clearText, '')
			
			sourceVideo = fname
			if os.path.exists(sourceVideo):
				# Get the Handbrake config values
				config = ConfigObj('config.ini')['Values']
				handbrakeCli = config['handbrakeCli']
				handbrakeOptions = config['handbrakeOptions']
				
				# Get the timestamp information on the file so that it can be set
				# to the original time of the filming rather than the time of the
				# conversion -- handy for keeping the chronological order.
				cTime = time.ctime(os.path.getmtime(sourceVideo))
				createTime = time.strptime(cTime)
				newCreateTime = time.strftime("%y%m%d%H%M.%S", createTime)
				
				# Build the destination folder and check to see if the file name is numeric
				destVideoFolder = os.path.join(self.m_tbxDestFolder.Value, time.strftime("%Y-%m-%d", createTime))
				newVideoName = os.path.basename(fname).split('.')[0]
				if newVideoName.isnumeric():
					newVideoName = str(int(newVideoName))
				
				# If the output folder does not exist, then create it
				if os.path.exists(destVideoFolder) == False:
					os.makedirs(destVideoFolder)
				
				# Build the new file name using the date and the newVideoName as a base
				destVideoName = time.strftime("%Y%m%d", createTime) + '_' + newVideoName + '.m4v'
				destVideo = os.path.join(destVideoFolder, destVideoName)
				
				# Set the threaded call to update the Status Bar
				wx.CallAfter(self.setStatus, 'Processing: ' + destVideoName)
				
				# Build the Handbrake command and set its parameters
				handbrakeCmd = '\"%s\" -i \"%s\" -o \"%s\" %s' % (handbrakeCli, sourceVideo, destVideo, handbrakeOptions)
				
				# Create the process and set the PIPE and STDOUT to grab the output								
				proc = subprocess.Popen(handbrakeCmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
					
				# Currently always show Output -- Setting this to False will stop the process from firing at all
				showOutput = True
				if showOutput:
					# Set the output buffer and start reading from the proc's STDOUT
					outBuffer = []
					while 1:
						# Read one character at a time and only update the screen
						# on newlines.  This will help performance, especially on
						# very long running conversions.  The more text in the Textbox,
						# the slower it will update.
						char = proc.stdout.read(1)
						if char == '\r' or char == '\n':
							outBuffer.append(char)
							wx.CallAfter(self.appendText, ''.join(outBuffer) )
							outBuffer = []
						else:
							outBuffer.append(char)
						
						# Check to see if Handbrake has exited.
						# If yes, then break out of the loop
						curOutput = self.m_tbxOutput.GetValue()
						if curOutput.find('has exited') >= 0:
							break
				
				# Give Handbrake a brief moment to release the file
				# and update its timestamp using another Popen call
				time.sleep(5)
				touchCmd = 'touch -mt ' + newCreateTime + ' \"%s\"' % (destVideo)
				proc = subprocess.Popen(touchCmd, shell=True).stdout
			
		self.m_statusBar.SetStatusText('Done!')	
